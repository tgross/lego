// Code generated by 'make generate-dns'; DO NOT EDIT.

package cmd

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"text/tabwriter"
)

func allDNSCodes() string {
	providers := []string{
		"manual",
		"acme-dns",
		"bunny",
		"exec",
		"route53",
	}
	sort.Strings(providers)
	return strings.Join(providers, ", ")
}

func displayDNSHelp(w io.Writer, name string) error {
	w = tabwriter.NewWriter(w, 0, 0, 2, ' ', 0)
	ew := &errWriter{w: w}

	switch name {
	case "acme-dns":
		// generated from: providers/dns/acmedns/acmedns.toml
		ew.writeln(`Configuration for Joohoi's ACME-DNS.`)
		ew.writeln(`Code:	'acme-dns'`)
		ew.writeln(`Since:	'v1.1.0'`)
		ew.writeln()

		ew.writeln(`Credentials:`)
		ew.writeln(`	- "ACME_DNS_API_BASE":	The ACME-DNS API address`)
		ew.writeln(`	- "ACME_DNS_STORAGE_PATH":	The ACME-DNS JSON account data file. A per-domain account will be registered/persisted to this file and used for TXT updates.`)
		ew.writeln()

		ew.writeln()
		ew.writeln(`More information: https://go-acme.github.io/lego/dns/acme-dns`)

	case "bunny":
		// generated from: providers/dns/bunny/bunny.toml
		ew.writeln(`Configuration for Bunny.`)
		ew.writeln(`Code:	'bunny'`)
		ew.writeln(`Since:	'v4.11.0'`)
		ew.writeln()

		ew.writeln(`Credentials:`)
		ew.writeln(`	- "BUNNY_API_KEY":	API key`)
		ew.writeln()

		ew.writeln(`Additional Configuration:`)
		ew.writeln(`	- "BUNNY_POLLING_INTERVAL":	Time between DNS propagation check`)
		ew.writeln(`	- "BUNNY_PROPAGATION_TIMEOUT":	Maximum waiting time for DNS propagation`)
		ew.writeln(`	- "BUNNY_TTL":	The TTL of the TXT record used for the DNS challenge`)

		ew.writeln()
		ew.writeln(`More information: https://go-acme.github.io/lego/dns/bunny`)

	case "exec":
		// generated from: providers/dns/exec/exec.toml
		ew.writeln(`Configuration for External program.`)
		ew.writeln(`Code:	'exec'`)
		ew.writeln(`Since:	'v0.5.0'`)
		ew.writeln()

		ew.writeln()
		ew.writeln(`More information: https://go-acme.github.io/lego/dns/exec`)

	case "route53":
		// generated from: providers/dns/route53/route53.toml
		ew.writeln(`Configuration for Amazon Route 53.`)
		ew.writeln(`Code:	'route53'`)
		ew.writeln(`Since:	'v0.3.0'`)
		ew.writeln()

		ew.writeln(`Credentials:`)
		ew.writeln(`	- "AWS_ACCESS_KEY_ID":	Managed by the AWS client. Access key ID ('AWS_ACCESS_KEY_ID_FILE' is not supported, use 'AWS_SHARED_CREDENTIALS_FILE' instead)`)
		ew.writeln(`	- "AWS_ASSUME_ROLE_ARN":	Managed by the AWS Role ARN ('AWS_ASSUME_ROLE_ARN_FILE' is not supported)`)
		ew.writeln(`	- "AWS_EXTERNAL_ID":	Managed by STS AssumeRole API operation ('AWS_EXTERNAL_ID_FILE' is not supported)`)
		ew.writeln(`	- "AWS_HOSTED_ZONE_ID":	Override the hosted zone ID.`)
		ew.writeln(`	- "AWS_PROFILE":	Managed by the AWS client ('AWS_PROFILE_FILE' is not supported)`)
		ew.writeln(`	- "AWS_REGION":	Managed by the AWS client ('AWS_REGION_FILE' is not supported)`)
		ew.writeln(`	- "AWS_SDK_LOAD_CONFIG":	Managed by the AWS client. Retrieve the region from the CLI config file ('AWS_SDK_LOAD_CONFIG_FILE' is not supported)`)
		ew.writeln(`	- "AWS_SECRET_ACCESS_KEY":	Managed by the AWS client. Secret access key ('AWS_SECRET_ACCESS_KEY_FILE' is not supported, use 'AWS_SHARED_CREDENTIALS_FILE' instead)`)
		ew.writeln(`	- "AWS_WAIT_FOR_RECORD_SETS_CHANGED":	Wait for changes to be INSYNC (it can be unstable)`)
		ew.writeln()

		ew.writeln(`Additional Configuration:`)
		ew.writeln(`	- "AWS_MAX_RETRIES":	The number of maximum returns the service will use to make an individual API request`)
		ew.writeln(`	- "AWS_POLLING_INTERVAL":	Time between DNS propagation check`)
		ew.writeln(`	- "AWS_PROPAGATION_TIMEOUT":	Maximum waiting time for DNS propagation`)
		ew.writeln(`	- "AWS_SHARED_CREDENTIALS_FILE":	Managed by the AWS client. Shared credentials file.`)
		ew.writeln(`	- "AWS_TTL":	The TTL of the TXT record used for the DNS challenge`)

		ew.writeln()
		ew.writeln(`More information: https://go-acme.github.io/lego/dns/route53`)

	case "manual":
		ew.writeln(`Solving the DNS-01 challenge using CLI prompt.`)
	default:
		return fmt.Errorf("%q is not yet supported", name)
	}

	if flusher, ok := w.(interface{ Flush() error }); ok {
		return flusher.Flush()
	}
	return nil
}
